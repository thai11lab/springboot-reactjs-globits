{"ast":null,"code":"/*\n * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec\n * \n * Public Domain. Use, modify and distribute it any way you like. No attribution required.\n *\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n *\n * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the\n * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for \n * Minified.js and should be perfect for embedding. \n *\n *\n * PinkySwear has just three functions.\n *\n * To create a new promise in pending state, call pinkySwear():\n *         var promise = pinkySwear();\n *\n * The returned object has a Promises/A+ compatible then() implementation:\n *          promise.then(function(value) { alert(\"Success!\"); }, function(value) { alert(\"Failure!\"); });\n *\n *\n * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and\n * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one\n * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: \n *         promise(true, [42]);\n *\n * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:\n *         promise(true, [6, 6, 6]);\n *         \n * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,\n * false if rejected, and otherwise undefined.\n * \t\t   var state = promise(); \n * \n * https://github.com/timjansen/PinkySwear.js\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.pinkySwear = factory();\n  }\n})(this, function () {\n  var undef;\n\n  function isFunction(f) {\n    return typeof f == 'function';\n  }\n\n  function isObject(f) {\n    return typeof f == 'object';\n  }\n\n  function defer(callback) {\n    if (typeof setImmediate != 'undefined') setImmediate(callback);else if (typeof process != 'undefined' && process['nextTick']) process['nextTick'](callback);else setTimeout(callback, 0);\n  }\n\n  return function pinkySwear(extend) {\n    var state; // undefined/null = pending, true = fulfilled, false = rejected\n\n    var values = []; // an array of values as arguments for the then() handlers\n\n    var deferred = []; // functions to call when set() is invoked\n\n    var set = function set(newState, newValues) {\n      if (state == null && newState != null) {\n        state = newState;\n        values = newValues;\n        if (deferred.length) defer(function () {\n          for (var i = 0; i < deferred.length; i++) deferred[i]();\n        });\n      }\n\n      return state;\n    };\n\n    set['then'] = function (onFulfilled, onRejected) {\n      var promise2 = pinkySwear(extend);\n\n      var callCallbacks = function callCallbacks() {\n        try {\n          var f = state ? onFulfilled : onRejected;\n\n          if (isFunction(f)) {\n            function resolve(x) {\n              var then,\n                  cbCalled = 0;\n\n              try {\n                if (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {\n                  if (x === promise2) throw new TypeError();\n                  then['call'](x, function () {\n                    if (!cbCalled++) resolve.apply(undef, arguments);\n                  }, function (value) {\n                    if (!cbCalled++) promise2(false, [value]);\n                  });\n                } else promise2(true, arguments);\n              } catch (e) {\n                if (!cbCalled++) promise2(false, [e]);\n              }\n            }\n\n            resolve(f.apply(undef, values || []));\n          } else promise2(state, values);\n        } catch (e) {\n          promise2(false, [e]);\n        }\n      };\n\n      if (state != null) defer(callCallbacks);else deferred.push(callCallbacks);\n      return promise2;\n    };\n\n    if (extend) {\n      set = extend(set);\n    }\n\n    return set;\n  };\n});","map":{"version":3,"sources":["D:/TraniningGlobits/baitap_level2/client/react/node_modules/pinkyswear/pinkyswear.js"],"names":["root","factory","define","amd","module","exports","pinkySwear","undef","isFunction","f","isObject","defer","callback","setImmediate","process","setTimeout","extend","state","values","deferred","set","newState","newValues","length","i","onFulfilled","onRejected","promise2","callCallbacks","resolve","x","then","cbCalled","TypeError","apply","arguments","value","e","push"],"mappings":"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","sourcesContent":["/*\n * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec\n * \n * Public Domain. Use, modify and distribute it any way you like. No attribution required.\n *\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n *\n * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the\n * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for \n * Minified.js and should be perfect for embedding. \n *\n *\n * PinkySwear has just three functions.\n *\n * To create a new promise in pending state, call pinkySwear():\n *         var promise = pinkySwear();\n *\n * The returned object has a Promises/A+ compatible then() implementation:\n *          promise.then(function(value) { alert(\"Success!\"); }, function(value) { alert(\"Failure!\"); });\n *\n *\n * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and\n * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one\n * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: \n *         promise(true, [42]);\n *\n * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:\n *         promise(true, [6, 6, 6]);\n *         \n * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,\n * false if rejected, and otherwise undefined.\n * \t\t   var state = promise(); \n * \n * https://github.com/timjansen/PinkySwear.js\n */\n(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine([], factory);\n\t} else if (typeof module === 'object' && module.exports) {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot.pinkySwear = factory();\n\t}\n}(this, function() {\n\tvar undef;\n\n\tfunction isFunction(f) {\n\t\treturn typeof f == 'function';\n\t}\n\tfunction isObject(f) {\n\t\treturn typeof f == 'object';\n\t}\n\tfunction defer(callback) {\n\t\tif (typeof setImmediate != 'undefined')\n\t\t\tsetImmediate(callback);\n\t\telse if (typeof process != 'undefined' && process['nextTick'])\n\t\t\tprocess['nextTick'](callback);\n\t\telse\n\t\t\tsetTimeout(callback, 0);\n\t}\n\n\treturn function pinkySwear(extend) {\n\t\tvar state;           // undefined/null = pending, true = fulfilled, false = rejected\n\t\tvar values = [];     // an array of values as arguments for the then() handlers\n\t\tvar deferred = [];   // functions to call when set() is invoked\n\n\t\tvar set = function(newState, newValues) {\n\t\t\tif (state == null && newState != null) {\n\t\t\t\tstate = newState;\n\t\t\t\tvalues = newValues;\n\t\t\t\tif (deferred.length)\n\t\t\t\t\tdefer(function() {\n\t\t\t\t\t\tfor (var i = 0; i < deferred.length; i++)\n\t\t\t\t\t\t\tdeferred[i]();\n\t\t\t\t\t});\n\t\t\t}\n\t\t\treturn state;\n\t\t};\n\n\t\tset['then'] = function (onFulfilled, onRejected) {\n\t\t\tvar promise2 = pinkySwear(extend);\n\t\t\tvar callCallbacks = function() {\n\t    \t\ttry {\n\t    \t\t\tvar f = (state ? onFulfilled : onRejected);\n\t    \t\t\tif (isFunction(f)) {\n\t\t   \t\t\t\tfunction resolve(x) {\n\t\t\t\t\t\t    var then, cbCalled = 0;\n\t\t   \t\t\t\t\ttry {\n\t\t\t\t   \t\t\t\tif (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {\n\t\t\t\t\t\t\t\t\t\tif (x === promise2)\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t\t\t\t\t\tthen['call'](x,\n\t\t\t\t\t\t\t\t\t\t\tfunction() { if (!cbCalled++) resolve.apply(undef,arguments); } ,\n\t\t\t\t\t\t\t\t\t\t\tfunction(value){ if (!cbCalled++) promise2(false,[value]);});\n\t\t\t\t   \t\t\t\t}\n\t\t\t\t   \t\t\t\telse\n\t\t\t\t   \t\t\t\t\tpromise2(true, arguments);\n\t\t   \t\t\t\t\t}\n\t\t   \t\t\t\t\tcatch(e) {\n\t\t   \t\t\t\t\t\tif (!cbCalled++)\n\t\t   \t\t\t\t\t\t\tpromise2(false, [e]);\n\t\t   \t\t\t\t\t}\n\t\t   \t\t\t\t}\n\t\t   \t\t\t\tresolve(f.apply(undef, values || []));\n\t\t   \t\t\t}\n\t\t   \t\t\telse\n\t\t   \t\t\t\tpromise2(state, values);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tpromise2(false, [e]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (state != null)\n\t\t\t\tdefer(callCallbacks);\n\t\t\telse\n\t\t\t\tdeferred.push(callCallbacks);\n\t\t\treturn promise2;\n\t\t};\n        if(extend){\n            set = extend(set);\n        }\n\t\treturn set;\n\t};\n}));\n\n"]},"metadata":{},"sourceType":"script"}