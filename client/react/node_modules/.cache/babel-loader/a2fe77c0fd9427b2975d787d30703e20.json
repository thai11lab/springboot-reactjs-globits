{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.endOfRange = endOfRange;\nexports.eventSegments = eventSegments;\nexports.eventLevels = eventLevels;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nvar dates = _interopRequireWildcard(require(\"./dates\"));\n\nfunction endOfRange(dateRange, unit) {\n  if (unit === void 0) {\n    unit = 'day';\n  }\n\n  return {\n    first: dateRange[0],\n    last: dates.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n}\n\nfunction eventSegments(event, range, accessors) {\n  var _endOfRange = endOfRange(range),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = dates.diff(first, last, 'day');\n  var start = dates.max(dates.startOf(accessors.start(event), 'day'), first);\n  var end = dates.min(dates.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return dates.eq(x, start, 'day');\n  });\n  var span = dates.diff(start, end, 'day');\n  span = Math.min(span, slots);\n  span = Math.max(span, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments, limit) {\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors) {\n  var eStart = dates.startOf(accessors.start(e), 'day');\n  var eEnd = accessors.end(e);\n  var startsBeforeEnd = dates.lte(eStart, end, 'day'); // when the event is zero duration we need to handle a bit differently\n\n  var endsAfterStart = !dates.eq(eStart, eEnd, 'minutes') ? dates.gt(eEnd, start, 'minutes') : dates.gte(eEnd, start, 'minutes');\n  return startsBeforeEnd && endsAfterStart;\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(evtA, evtB, accessors) {\n  var startSort = +dates.startOf(accessors.start(evtA), 'day') - +dates.startOf(accessors.start(evtB), 'day');\n  var durA = dates.diff(accessors.start(evtA), dates.ceil(accessors.end(evtA), 'day'), 'day');\n  var durB = dates.diff(accessors.start(evtB), dates.ceil(accessors.end(evtB), 'day'), 'day');\n  return startSort || // sort by start Day first\n  Math.max(durB, 1) - Math.max(durA, 1) || // events spanning multiple days go first\n  !!accessors.allDay(evtB) - !!accessors.allDay(evtA) || // then allDay single day events\n  +accessors.start(evtA) - +accessors.start(evtB); // then sort by start time\n}","map":{"version":3,"sources":["D:/TraniningGlobits/baitap_level2/client/react/node_modules/react-big-calendar/lib/utils/eventLevels.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","exports","__esModule","endOfRange","eventSegments","eventLevels","inRange","segsOverlap","sortEvents","_findIndex","dates","dateRange","unit","first","last","add","length","event","range","accessors","_endOfRange","slots","diff","start","max","startOf","end","min","ceil","padding","default","x","eq","span","Math","left","right","rowSegments","limit","Infinity","i","j","seg","levels","extra","push","sort","a","b","e","eStart","eEnd","startsBeforeEnd","lte","endsAfterStart","gt","gte","otherSegs","some","otherSeg","evtA","evtB","startSort","durA","durB","allDay"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.endOfRange = endOfRange;\nexports.eventSegments = eventSegments;\nexports.eventLevels = eventLevels;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nvar dates = _interopRequireWildcard(require(\"./dates\"));\n\nfunction endOfRange(dateRange, unit) {\n  if (unit === void 0) {\n    unit = 'day';\n  }\n\n  return {\n    first: dateRange[0],\n    last: dates.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n}\n\nfunction eventSegments(event, range, accessors) {\n  var _endOfRange = endOfRange(range),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = dates.diff(first, last, 'day');\n  var start = dates.max(dates.startOf(accessors.start(event), 'day'), first);\n  var end = dates.min(dates.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return dates.eq(x, start, 'day');\n  });\n  var span = dates.diff(start, end, 'day');\n  span = Math.min(span, slots);\n  span = Math.max(span, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments, limit) {\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors) {\n  var eStart = dates.startOf(accessors.start(e), 'day');\n  var eEnd = accessors.end(e);\n  var startsBeforeEnd = dates.lte(eStart, end, 'day'); // when the event is zero duration we need to handle a bit differently\n\n  var endsAfterStart = !dates.eq(eStart, eEnd, 'minutes') ? dates.gt(eEnd, start, 'minutes') : dates.gte(eEnd, start, 'minutes');\n  return startsBeforeEnd && endsAfterStart;\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(evtA, evtB, accessors) {\n  var startSort = +dates.startOf(accessors.start(evtA), 'day') - +dates.startOf(accessors.start(evtB), 'day');\n  var durA = dates.diff(accessors.start(evtA), dates.ceil(accessors.end(evtA), 'day'), 'day');\n  var durB = dates.diff(accessors.start(evtB), dates.ceil(accessors.end(evtB), 'day'), 'day');\n  return startSort || // sort by start Day first\n  Math.max(durB, 1) - Math.max(durA, 1) || // events spanning multiple days go first\n  !!accessors.allDay(evtB) - !!accessors.allDay(evtA) || // then allDay single day events\n  +accessors.start(evtA) - +accessors.start(evtB); // then sort by start time\n}"]},"metadata":{},"sourceType":"script"}